/**
 * 
 */
package eu.scape_project.pc.cc.nanite.tika;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;

import org.apache.commons.io.IOUtils;
import org.apache.log4j.Logger;
import org.apache.tika.Tika;
import org.apache.tika.detect.CompositeDetector;
import org.apache.tika.detect.Detector;
import org.apache.tika.metadata.Metadata;
import org.apache.tika.parser.CompositeParser;
import org.apache.tika.parser.ParseContext;
import org.apache.tika.sax.WriteOutContentHandler;

/**
 * @author Andrew Jackson <Andrew.Jackson@bl.uk>
 *
 */
public class TikaDeepIdentifier {
	private static Logger log = Logger.getLogger(TikaDeepIdentifier.class.getName());
	
	private static int MAX_BUF = 64*1024;

	Tika tika = new Tika();
	
	// Abort handler, limiting the output size, to avoid OOM:
	WriteOutContentHandler ch = new WriteOutContentHandler(MAX_BUF);
	// Silent handler:
	//ContentHandler ch = new DefaultHandler();
	
	// Set up a parse context:
	ParseContext ctx = new ParseContext();
	// Set up the parser:
	PreservationParser parser = new PreservationParser();

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		System.out.println("TEST...");
		TikaDeepIdentifier tdi = new TikaDeepIdentifier();
		tdi.printDetectors();
		System.out.println("GOT: "+tdi.identify(new byte[] {'%','P','D','F','-'}));
	}
	
	public void printDetectors() {
		CompositeDetector ds = (CompositeDetector) tika.getDetector();
		for( Detector d : ds.getDetectors()) {
			System.out.println("T: "+d.getClass().getCanonicalName());
		}		
	}

	/**
	 * 
	 * @param payload
	 * @return
	 */
	public String identify(byte[] payload) {
		// Fallback
		String tikaType = ExtendedMimeType.OCTET_STREAM.toString();
		try {
			// Type according to Tiki:
			tikaType = tika.detect( payload );
		} catch( Throwable e ) {
			log.error( "Tika.detect failed:" + e.getMessage() );
			//e.printStackTrace();
			return ExtendedMimeType.OCTET_STREAM.toString();
		}

		// Now perform full parse, to find a more detailed tikaType
		try {
			// Set up metadata object:
			Metadata md = new Metadata();
			md.set( Metadata.CONTENT_TYPE, tikaType );
			
			// Ensure parsing is NOT recursive:
			parser.setRecursive(ctx, false);
			
			// Now perform the parsing:
			parser.parse( new ByteArrayInputStream( payload ), ch, md, ctx );
			// One could forcibly limit the size if OOM is still causing problems, like this:
			//parser.parse( new ByteArrayInputStream( value.getPayload(), 0, BUF_8KB ), ch, md, ctx );
			
			// Use the extended MIME type generated by the PreservationParser:
			String extMimeType = md.get(PreservationParser.EXT_MIME_TYPE);
			if( extMimeType != null ) tikaType = extMimeType;
			
		} catch( Throwable e ) {
			log.warn( "Tika Exception: " + e.getMessage() );
			//e.printStackTrace();
		}
		// Return whichever value works:
		return tikaType;
	}

	private File copyToTempFile( String name, byte[] content, int max_bytes ) throws Exception {
		File tmp = File.createTempFile("FmtTmp-", name);
		tmp.deleteOnExit();
		FileOutputStream fos = new FileOutputStream(tmp);
		IOUtils.copy(new ByteArrayInputStream(content, 0, max_bytes), fos);
		fos.flush();
		fos.close();
		return tmp;
	}
	
	private File copyToTempFile( String name, byte[] content ) throws Exception {
		//if( content.length < BUF_8KB )
		return copyToTempFile(name, content, MAX_BUF);
	}
	
}
